"""
Main script to run the Handwritten PDF to LaTeX conversion process.
"""

import argparse
import os
import time
import subprocess # Added for running external commands
import shutil # Added for checking if latexmk is available

# Import functions from our modules (now using the installable package)
from core_converter.pdf_processing.processor import render_pdf_to_image
from core_converter.vlm_interaction.api_client import get_latex_from_image
from core_converter.latex_generation.generator import save_latex_to_file

# Define base directories relative to this script location
# This assumes main.py is in apps/cli/src/
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(BASE_DIR)
DEFAULT_OUTPUT_DIR = os.path.join(PROJECT_ROOT, 'output_latex')
DEFAULT_IMAGE_DIR = os.path.join(PROJECT_ROOT, 'output_images') # For intermediate images
DEFAULT_MODEL = "o4-mini"

def compile_latex_to_pdf(tex_filepath: str, output_directory: str) -> bool:
    """
    Compiles a .tex file to a PDF using latexmk.
    The PDF will be placed in the specified output_directory.

    Args:
        tex_filepath: Absolute path to the input .tex file.
        output_directory: Directory where the PDF should be saved.

    Returns:
        True if compilation was successful, False otherwise.
    """
    if not shutil.which("latexmk"):
        print("\nWarning: latexmk command not found. Skipping PDF compilation.")
        print("Please install a LaTeX distribution with latexmk to enable PDF generation.")
        return False

    print(f"\nStep 4: Compiling {os.path.basename(tex_filepath)} to PDF...")
    
    # Ensure the output directory for PDF exists (latexmk might handle this, but good to be sure)
    os.makedirs(output_directory, exist_ok=True)

    # latexmk options:
    # -pdf: Generate PDF output
    # -output-directory: Specify where output files (PDF, aux, log) should go
    # -interaction=nonstopmode: Prevents latexmk from stopping on errors (it will still report them)
    # -file-line-error: Provides more precise error messages
    command = [
        "latexmk",
        "-pdf",
        f"-output-directory={output_directory}",
        "-interaction=nonstopmode",
        "-file-line-error",
        tex_filepath
    ]

    try:
        # Capture output to check for errors
        process = subprocess.run(command, capture_output=True, text=True, check=False, timeout=120) # Added timeout
        
        pdf_filename = os.path.splitext(os.path.basename(tex_filepath))[0] + ".pdf"
        expected_pdf_path = os.path.join(output_directory, pdf_filename)

        if process.returncode == 0 and os.path.exists(expected_pdf_path):
            print(f"Successfully compiled PDF: {expected_pdf_path}")
            # Clean up auxiliary files generated by latexmk in the output directory
            # latexmk -c -output-directory=<output_directory> <tex_filepath_without_ext_or_dir>
            # We need to run cleanup from the output directory or specify full paths for aux files
            cleanup_command = [
                "latexmk",
                "-c",
                f"-output-directory={output_directory}", # Ensure cleanup targets correct dir
                tex_filepath # Provide full path to .tex file for context
            ]
            # Simpler: clean up common aux files directly if -c is problematic across environments
            # For now, let's try the latexmk -c command
            subprocess.run(cleanup_command, capture_output=True, text=True, check=False, cwd=output_directory) # Run cleanup
            print(f"Cleaned up auxiliary files in {output_directory}")
            return True
        else:
            print(f"Error during PDF compilation for {os.path.basename(tex_filepath)}.")
            print(f"Return code: {process.returncode}")
            if process.stdout:
                print("Stdout:\n", process.stdout)
            if process.stderr:
                print("Stderr:\n", process.stderr)
            if not os.path.exists(expected_pdf_path):
                print(f"Output PDF not found at: {expected_pdf_path}")
            return False
            
    except subprocess.TimeoutExpired:
        print(f"Error: PDF compilation for {os.path.basename(tex_filepath)} timed out after 120 seconds.")
        return False
    except Exception as e:
        print(f"An unexpected error occurred during PDF compilation: {e}")
        return False

def main(pdf_path: str, output_dir: str, models_to_run: list[str]):
    """Runs the main conversion pipeline for one or more models."""
    print(f"Starting conversion process for: {pdf_path}")
    print(f"Models to run: {', '.join(models_to_run)}")
    overall_start_time = time.time()

    # --- 1. Define Base Paths & Render PDF (Done once) ---
    pdf_filename = os.path.basename(pdf_path)
    base_filename = os.path.splitext(pdf_filename)[0]
    
    os.makedirs(DEFAULT_IMAGE_DIR, exist_ok=True)
    image_output_path = os.path.join(DEFAULT_IMAGE_DIR, f"{base_filename}_page0.png")
    
    print("\nStep 1: Rendering PDF to image (once for all models)...")
    generated_image_path = render_pdf_to_image(pdf_path, image_output_path)
    
    if not generated_image_path:
        print("Failed to render PDF to image. Exiting.")
        return

    # --- Loop Through Models --- 
    all_success = True
    for model_name in models_to_run:
        model_start_time = time.time()
        print(f"\n===== Processing Model: {model_name} =====")

        # --- 2. Get LaTeX from Image (via VLM) ---
        print(f"Step 2: Sending image to {model_name} for LaTeX conversion...")
        # Unpack the tuple returned by get_latex_from_image
        latex_content, descriptions_text = get_latex_from_image(generated_image_path, model_name=model_name)
        
        # Check if LaTeX content is missing or if it's the dummy/placeholder output
        if not latex_content or "DUMMY_LATEX_OUTPUT" in latex_content:
            print(f"Failed to get LaTeX from {model_name} (or placeholder failed). Skipping model.")
            all_success = False
            continue # Move to the next model

        # --- 3. Save LaTeX to File ---
        # Modify output filename to include model name and input base filename
        os.makedirs(output_dir, exist_ok=True)
        tex_output_path = os.path.join(output_dir, f"{base_filename}_{model_name}.tex")
        
        print(f"Step 3: Saving generated LaTeX content for {model_name}...")
        # Pass only the latex_content string to the save function
        success = save_latex_to_file(latex_content, tex_output_path)
        if success:
            print(f"Output LaTeX file for {model_name} saved to: {tex_output_path}")
            # Attempt to compile the generated .tex file to PDF
            compile_latex_to_pdf(tex_output_path, output_dir)
        else:
            print(f"Failed to save the LaTeX file for {model_name}.")
            all_success = False
        
        model_end_time = time.time()
        print(f"===== Finished processing {model_name} in {model_end_time - model_start_time:.2f} seconds =====")

    # --- 4. Clean up and Final Report ---
    # Optionally delete intermediate image after all models are processed
    # if all_success: # Or maybe always delete if it exists?
    #     try:
    #         os.remove(generated_image_path)
    #         print(f"\nCleaned up intermediate image: {generated_image_path}")
    #     except OSError as e:
    #         print(f"\nWarning: Could not delete intermediate image {generated_image_path}: {e}")

    overall_end_time = time.time()
    print(f"\nOverall conversion process finished in {overall_end_time - overall_start_time:.2f} seconds.")
    if not all_success:
        print("Note: One or more models failed during processing.")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Convert a handwritten PDF (first page) to LaTeX files using one or more OpenAI models.")
    parser.add_argument("pdf_path", help="Path to the input PDF file.")
    parser.add_argument("-o", "--output-dir", default=DEFAULT_OUTPUT_DIR, 
                        help=f"Directory to save the output .tex files (defaults to: {DEFAULT_OUTPUT_DIR})")
    parser.add_argument("-m", "--models", default=DEFAULT_MODEL, 
                        help=f"Comma-separated list of OpenAI model names to use (e.g., 'gpt-4-vision-preview,gpt-4o'). Defaults to: {DEFAULT_MODEL}")
    
    args = parser.parse_args()
    
    # Split the comma-separated models string into a list
    models_list = [model.strip() for model in args.models.split(',') if model.strip()]

    if not models_list:
        print("Error: No valid models specified.")
    elif not os.path.isfile(args.pdf_path):
        print(f"Error: Input PDF file not found at '{args.pdf_path}'")
    else:
        main(args.pdf_path, args.output_dir, models_list)
